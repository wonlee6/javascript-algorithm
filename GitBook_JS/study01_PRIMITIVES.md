# 원시 값의 메소드

### 원시값

- 원시형 값
- 원시형의 종류
  - String, Number, Boolean, Null, Undefiend, Symbol, bigint 총 7개

### 객체

- 프로퍼티에 다양한 종류의 값을 저장할 수 있다.
- > {name : "John", age : 30}와 같은 형태
- 함수도 객체의 일종

<br>

#### 객체의 장점 중 하나는 함수를 프로퍼티로 저장할 수 있다는 것

```js
let john = {
  name: 'John',
  sayHi: function () {
    alert('친구야 반갑다!');
  },
};

john.sayHi(); // 친구야 반갑다!
```

위와 같은 기능을 사용하면 시스템 자원이 많이 소모된다는 단점이 있다.  
객체는 원시값보다 “무겁고”, 내부 구조를 유지하기 위해 추가 자원을 사용하기 때문

문제점을 해결하기 위해 특수한 객체, "원시 래퍼 객체(object wrapper)"를 만든다(이 객체는 바로 삭제됨)

"래퍼 객체"는 원시 타입에 따라 종류가 다양, 각 래퍼 객체는 원시 자료형의 이름을 그대로 차용해, `String` , `Number`, `Boolean`, `Symbol`라고 부릅니다.

`toUpperCase`로 예를 들면,

```js
let str = 'Hello';

alert(str.toUpperCase()); // HELLO
```

#### 내부에서 일어나는 일

1.문자열 str은 원시값이므로 원시값의 프로퍼티(toUpperCase)에 접근하는 순간 특별한 객체가 만들어 지고, 이 객체는 문자열의 값을 알고 있고, toUpperCase()와 같은 유용한 메서드를 가지고 있음.  
2.메서드가 실행되고, 새로운 문자열이 반환(alert 창에 이 문자열이 출력)  
3.특별한 객체는 파괴되고, 원시값 str만 남는다.

> 이런 내부 프로세스를 통해 원시값을 가볍게 유지하면서 메서드를 호출할 수 있는 것.

```js
let str = 'Hello';

str.test = 5; // (*)

alert(str.test);
```

- 원시값과 객체는 다르다는 것
- 원시값은 추가 데이터를 저장할 수 없다.

### 주의 할 점❗

`String/Number/Boolean`를 생성자론 쓰지 말자.  
Java 등의 몇몇 언어에선 new Number(1) 또는 new Boolean(false)와 같은 문법을 사용해 원하는 타입의 "래퍼 객체"를 직접 만들 수 있습니다.

자바스크립트에서도 하위 호환성을 위해 이 기능을 남겨 두었는데, 이런 식으로 래퍼 객체를 만드는 건 추천하지 않음. 몇몇 상황에서 혼동을 불러일으키기 때문.




